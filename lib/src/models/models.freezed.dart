// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SubscriptionStoreProduct _$SubscriptionStoreProductFromJson(
    Map<String, dynamic> json) {
  return _SubscriptionStoreProduct.fromJson(json);
}

/// @nodoc
mixin _$SubscriptionStoreProduct {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  double get price => throw _privateConstructorUsedError;
  String get formattedPrice => throw _privateConstructorUsedError;
  String get currencyCode => throw _privateConstructorUsedError;
  SubscriptionStore get store => throw _privateConstructorUsedError;
  int get subscriptionRecurrenceDays => throw _privateConstructorUsedError;
  String get accessLevel => throw _privateConstructorUsedError;

  /// Serializes this SubscriptionStoreProduct to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SubscriptionStoreProduct
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SubscriptionStoreProductCopyWith<SubscriptionStoreProduct> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionStoreProductCopyWith<$Res> {
  factory $SubscriptionStoreProductCopyWith(SubscriptionStoreProduct value,
          $Res Function(SubscriptionStoreProduct) then) =
      _$SubscriptionStoreProductCopyWithImpl<$Res, SubscriptionStoreProduct>;
  @useResult
  $Res call(
      {String id,
      String name,
      String description,
      double price,
      String formattedPrice,
      String currencyCode,
      SubscriptionStore store,
      int subscriptionRecurrenceDays,
      String accessLevel});
}

/// @nodoc
class _$SubscriptionStoreProductCopyWithImpl<$Res,
        $Val extends SubscriptionStoreProduct>
    implements $SubscriptionStoreProductCopyWith<$Res> {
  _$SubscriptionStoreProductCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubscriptionStoreProduct
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? description = null,
    Object? price = null,
    Object? formattedPrice = null,
    Object? currencyCode = null,
    Object? store = null,
    Object? subscriptionRecurrenceDays = null,
    Object? accessLevel = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as double,
      formattedPrice: null == formattedPrice
          ? _value.formattedPrice
          : formattedPrice // ignore: cast_nullable_to_non_nullable
              as String,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
      store: null == store
          ? _value.store
          : store // ignore: cast_nullable_to_non_nullable
              as SubscriptionStore,
      subscriptionRecurrenceDays: null == subscriptionRecurrenceDays
          ? _value.subscriptionRecurrenceDays
          : subscriptionRecurrenceDays // ignore: cast_nullable_to_non_nullable
              as int,
      accessLevel: null == accessLevel
          ? _value.accessLevel
          : accessLevel // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SubscriptionStoreProductImplCopyWith<$Res>
    implements $SubscriptionStoreProductCopyWith<$Res> {
  factory _$$SubscriptionStoreProductImplCopyWith(
          _$SubscriptionStoreProductImpl value,
          $Res Function(_$SubscriptionStoreProductImpl) then) =
      __$$SubscriptionStoreProductImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String description,
      double price,
      String formattedPrice,
      String currencyCode,
      SubscriptionStore store,
      int subscriptionRecurrenceDays,
      String accessLevel});
}

/// @nodoc
class __$$SubscriptionStoreProductImplCopyWithImpl<$Res>
    extends _$SubscriptionStoreProductCopyWithImpl<$Res,
        _$SubscriptionStoreProductImpl>
    implements _$$SubscriptionStoreProductImplCopyWith<$Res> {
  __$$SubscriptionStoreProductImplCopyWithImpl(
      _$SubscriptionStoreProductImpl _value,
      $Res Function(_$SubscriptionStoreProductImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionStoreProduct
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? description = null,
    Object? price = null,
    Object? formattedPrice = null,
    Object? currencyCode = null,
    Object? store = null,
    Object? subscriptionRecurrenceDays = null,
    Object? accessLevel = null,
  }) {
    return _then(_$SubscriptionStoreProductImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as double,
      formattedPrice: null == formattedPrice
          ? _value.formattedPrice
          : formattedPrice // ignore: cast_nullable_to_non_nullable
              as String,
      currencyCode: null == currencyCode
          ? _value.currencyCode
          : currencyCode // ignore: cast_nullable_to_non_nullable
              as String,
      store: null == store
          ? _value.store
          : store // ignore: cast_nullable_to_non_nullable
              as SubscriptionStore,
      subscriptionRecurrenceDays: null == subscriptionRecurrenceDays
          ? _value.subscriptionRecurrenceDays
          : subscriptionRecurrenceDays // ignore: cast_nullable_to_non_nullable
              as int,
      accessLevel: null == accessLevel
          ? _value.accessLevel
          : accessLevel // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SubscriptionStoreProductImpl implements _SubscriptionStoreProduct {
  _$SubscriptionStoreProductImpl(
      {required this.id,
      required this.name,
      required this.description,
      required this.price,
      required this.formattedPrice,
      required this.currencyCode,
      required this.store,
      required this.subscriptionRecurrenceDays,
      required this.accessLevel});

  factory _$SubscriptionStoreProductImpl.fromJson(Map<String, dynamic> json) =>
      _$$SubscriptionStoreProductImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String description;
  @override
  final double price;
  @override
  final String formattedPrice;
  @override
  final String currencyCode;
  @override
  final SubscriptionStore store;
  @override
  final int subscriptionRecurrenceDays;
  @override
  final String accessLevel;

  @override
  String toString() {
    return 'SubscriptionStoreProduct(id: $id, name: $name, description: $description, price: $price, formattedPrice: $formattedPrice, currencyCode: $currencyCode, store: $store, subscriptionRecurrenceDays: $subscriptionRecurrenceDays, accessLevel: $accessLevel)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscriptionStoreProductImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.price, price) || other.price == price) &&
            (identical(other.formattedPrice, formattedPrice) ||
                other.formattedPrice == formattedPrice) &&
            (identical(other.currencyCode, currencyCode) ||
                other.currencyCode == currencyCode) &&
            (identical(other.store, store) || other.store == store) &&
            (identical(other.subscriptionRecurrenceDays,
                    subscriptionRecurrenceDays) ||
                other.subscriptionRecurrenceDays ==
                    subscriptionRecurrenceDays) &&
            (identical(other.accessLevel, accessLevel) ||
                other.accessLevel == accessLevel));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      description,
      price,
      formattedPrice,
      currencyCode,
      store,
      subscriptionRecurrenceDays,
      accessLevel);

  /// Create a copy of SubscriptionStoreProduct
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubscriptionStoreProductImplCopyWith<_$SubscriptionStoreProductImpl>
      get copyWith => __$$SubscriptionStoreProductImplCopyWithImpl<
          _$SubscriptionStoreProductImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SubscriptionStoreProductImplToJson(
      this,
    );
  }
}

abstract class _SubscriptionStoreProduct implements SubscriptionStoreProduct {
  factory _SubscriptionStoreProduct(
      {required final String id,
      required final String name,
      required final String description,
      required final double price,
      required final String formattedPrice,
      required final String currencyCode,
      required final SubscriptionStore store,
      required final int subscriptionRecurrenceDays,
      required final String accessLevel}) = _$SubscriptionStoreProductImpl;

  factory _SubscriptionStoreProduct.fromJson(Map<String, dynamic> json) =
      _$SubscriptionStoreProductImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get description;
  @override
  double get price;
  @override
  String get formattedPrice;
  @override
  String get currencyCode;
  @override
  SubscriptionStore get store;
  @override
  int get subscriptionRecurrenceDays;
  @override
  String get accessLevel;

  /// Create a copy of SubscriptionStoreProduct
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubscriptionStoreProductImplCopyWith<_$SubscriptionStoreProductImpl>
      get copyWith => throw _privateConstructorUsedError;
}

CrosspayEntitlement _$CrosspayEntitlementFromJson(Map<String, dynamic> json) {
  return _CrosspayEntitlement.fromJson(json);
}

/// @nodoc
mixin _$CrosspayEntitlement {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  @JsonKey(
      name: "period_ms",
      fromJson: _durationFromMillis,
      toJson: _durationToMillis)
  Duration get period => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;
  CrosspayProducts get products => throw _privateConstructorUsedError;

  /// Serializes this CrosspayEntitlement to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CrosspayEntitlement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CrosspayEntitlementCopyWith<CrosspayEntitlement> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CrosspayEntitlementCopyWith<$Res> {
  factory $CrosspayEntitlementCopyWith(
          CrosspayEntitlement value, $Res Function(CrosspayEntitlement) then) =
      _$CrosspayEntitlementCopyWithImpl<$Res, CrosspayEntitlement>;
  @useResult
  $Res call(
      {String id,
      String name,
      @JsonKey(
          name: "period_ms",
          fromJson: _durationFromMillis,
          toJson: _durationToMillis)
      Duration period,
      String? description,
      Map<String, dynamic>? metadata,
      CrosspayProducts products});

  $CrosspayProductsCopyWith<$Res> get products;
}

/// @nodoc
class _$CrosspayEntitlementCopyWithImpl<$Res, $Val extends CrosspayEntitlement>
    implements $CrosspayEntitlementCopyWith<$Res> {
  _$CrosspayEntitlementCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CrosspayEntitlement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? period = null,
    Object? description = freezed,
    Object? metadata = freezed,
    Object? products = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      period: null == period
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as Duration,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      products: null == products
          ? _value.products
          : products // ignore: cast_nullable_to_non_nullable
              as CrosspayProducts,
    ) as $Val);
  }

  /// Create a copy of CrosspayEntitlement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CrosspayProductsCopyWith<$Res> get products {
    return $CrosspayProductsCopyWith<$Res>(_value.products, (value) {
      return _then(_value.copyWith(products: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CrosspayEntitlementImplCopyWith<$Res>
    implements $CrosspayEntitlementCopyWith<$Res> {
  factory _$$CrosspayEntitlementImplCopyWith(_$CrosspayEntitlementImpl value,
          $Res Function(_$CrosspayEntitlementImpl) then) =
      __$$CrosspayEntitlementImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @JsonKey(
          name: "period_ms",
          fromJson: _durationFromMillis,
          toJson: _durationToMillis)
      Duration period,
      String? description,
      Map<String, dynamic>? metadata,
      CrosspayProducts products});

  @override
  $CrosspayProductsCopyWith<$Res> get products;
}

/// @nodoc
class __$$CrosspayEntitlementImplCopyWithImpl<$Res>
    extends _$CrosspayEntitlementCopyWithImpl<$Res, _$CrosspayEntitlementImpl>
    implements _$$CrosspayEntitlementImplCopyWith<$Res> {
  __$$CrosspayEntitlementImplCopyWithImpl(_$CrosspayEntitlementImpl _value,
      $Res Function(_$CrosspayEntitlementImpl) _then)
      : super(_value, _then);

  /// Create a copy of CrosspayEntitlement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? period = null,
    Object? description = freezed,
    Object? metadata = freezed,
    Object? products = null,
  }) {
    return _then(_$CrosspayEntitlementImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      period: null == period
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as Duration,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      products: null == products
          ? _value.products
          : products // ignore: cast_nullable_to_non_nullable
              as CrosspayProducts,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CrosspayEntitlementImpl implements _CrosspayEntitlement {
  _$CrosspayEntitlementImpl(
      {required this.id,
      required this.name,
      @JsonKey(
          name: "period_ms",
          fromJson: _durationFromMillis,
          toJson: _durationToMillis)
      required this.period,
      this.description,
      final Map<String, dynamic>? metadata,
      required this.products})
      : _metadata = metadata;

  factory _$CrosspayEntitlementImpl.fromJson(Map<String, dynamic> json) =>
      _$$CrosspayEntitlementImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  @JsonKey(
      name: "period_ms",
      fromJson: _durationFromMillis,
      toJson: _durationToMillis)
  final Duration period;
  @override
  final String? description;
  final Map<String, dynamic>? _metadata;
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final CrosspayProducts products;

  @override
  String toString() {
    return 'CrosspayEntitlement(id: $id, name: $name, period: $period, description: $description, metadata: $metadata, products: $products)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CrosspayEntitlementImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.period, period) || other.period == period) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.products, products) ||
                other.products == products));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, period, description,
      const DeepCollectionEquality().hash(_metadata), products);

  /// Create a copy of CrosspayEntitlement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CrosspayEntitlementImplCopyWith<_$CrosspayEntitlementImpl> get copyWith =>
      __$$CrosspayEntitlementImplCopyWithImpl<_$CrosspayEntitlementImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CrosspayEntitlementImplToJson(
      this,
    );
  }
}

abstract class _CrosspayEntitlement implements CrosspayEntitlement {
  factory _CrosspayEntitlement(
      {required final String id,
      required final String name,
      @JsonKey(
          name: "period_ms",
          fromJson: _durationFromMillis,
          toJson: _durationToMillis)
      required final Duration period,
      final String? description,
      final Map<String, dynamic>? metadata,
      required final CrosspayProducts products}) = _$CrosspayEntitlementImpl;

  factory _CrosspayEntitlement.fromJson(Map<String, dynamic> json) =
      _$CrosspayEntitlementImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  @JsonKey(
      name: "period_ms",
      fromJson: _durationFromMillis,
      toJson: _durationToMillis)
  Duration get period;
  @override
  String? get description;
  @override
  Map<String, dynamic>? get metadata;
  @override
  CrosspayProducts get products;

  /// Create a copy of CrosspayEntitlement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CrosspayEntitlementImplCopyWith<_$CrosspayEntitlementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CrosspayProducts _$CrosspayProductsFromJson(Map<String, dynamic> json) {
  return _CrosspayProducts.fromJson(json);
}

/// @nodoc
mixin _$CrosspayProducts {
  @JsonKey(name: "playstore")
  CrosspayProduct get playStore => throw _privateConstructorUsedError;
  @JsonKey(name: "appstore")
  CrosspayProduct get appStore => throw _privateConstructorUsedError;
  CrosspayProduct get stripe => throw _privateConstructorUsedError;

  /// Serializes this CrosspayProducts to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CrosspayProducts
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CrosspayProductsCopyWith<CrosspayProducts> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CrosspayProductsCopyWith<$Res> {
  factory $CrosspayProductsCopyWith(
          CrosspayProducts value, $Res Function(CrosspayProducts) then) =
      _$CrosspayProductsCopyWithImpl<$Res, CrosspayProducts>;
  @useResult
  $Res call(
      {@JsonKey(name: "playstore") CrosspayProduct playStore,
      @JsonKey(name: "appstore") CrosspayProduct appStore,
      CrosspayProduct stripe});

  $CrosspayProductCopyWith<$Res> get playStore;
  $CrosspayProductCopyWith<$Res> get appStore;
  $CrosspayProductCopyWith<$Res> get stripe;
}

/// @nodoc
class _$CrosspayProductsCopyWithImpl<$Res, $Val extends CrosspayProducts>
    implements $CrosspayProductsCopyWith<$Res> {
  _$CrosspayProductsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CrosspayProducts
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? playStore = null,
    Object? appStore = null,
    Object? stripe = null,
  }) {
    return _then(_value.copyWith(
      playStore: null == playStore
          ? _value.playStore
          : playStore // ignore: cast_nullable_to_non_nullable
              as CrosspayProduct,
      appStore: null == appStore
          ? _value.appStore
          : appStore // ignore: cast_nullable_to_non_nullable
              as CrosspayProduct,
      stripe: null == stripe
          ? _value.stripe
          : stripe // ignore: cast_nullable_to_non_nullable
              as CrosspayProduct,
    ) as $Val);
  }

  /// Create a copy of CrosspayProducts
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CrosspayProductCopyWith<$Res> get playStore {
    return $CrosspayProductCopyWith<$Res>(_value.playStore, (value) {
      return _then(_value.copyWith(playStore: value) as $Val);
    });
  }

  /// Create a copy of CrosspayProducts
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CrosspayProductCopyWith<$Res> get appStore {
    return $CrosspayProductCopyWith<$Res>(_value.appStore, (value) {
      return _then(_value.copyWith(appStore: value) as $Val);
    });
  }

  /// Create a copy of CrosspayProducts
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CrosspayProductCopyWith<$Res> get stripe {
    return $CrosspayProductCopyWith<$Res>(_value.stripe, (value) {
      return _then(_value.copyWith(stripe: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CrosspayProductsImplCopyWith<$Res>
    implements $CrosspayProductsCopyWith<$Res> {
  factory _$$CrosspayProductsImplCopyWith(_$CrosspayProductsImpl value,
          $Res Function(_$CrosspayProductsImpl) then) =
      __$$CrosspayProductsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "playstore") CrosspayProduct playStore,
      @JsonKey(name: "appstore") CrosspayProduct appStore,
      CrosspayProduct stripe});

  @override
  $CrosspayProductCopyWith<$Res> get playStore;
  @override
  $CrosspayProductCopyWith<$Res> get appStore;
  @override
  $CrosspayProductCopyWith<$Res> get stripe;
}

/// @nodoc
class __$$CrosspayProductsImplCopyWithImpl<$Res>
    extends _$CrosspayProductsCopyWithImpl<$Res, _$CrosspayProductsImpl>
    implements _$$CrosspayProductsImplCopyWith<$Res> {
  __$$CrosspayProductsImplCopyWithImpl(_$CrosspayProductsImpl _value,
      $Res Function(_$CrosspayProductsImpl) _then)
      : super(_value, _then);

  /// Create a copy of CrosspayProducts
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? playStore = null,
    Object? appStore = null,
    Object? stripe = null,
  }) {
    return _then(_$CrosspayProductsImpl(
      playStore: null == playStore
          ? _value.playStore
          : playStore // ignore: cast_nullable_to_non_nullable
              as CrosspayProduct,
      appStore: null == appStore
          ? _value.appStore
          : appStore // ignore: cast_nullable_to_non_nullable
              as CrosspayProduct,
      stripe: null == stripe
          ? _value.stripe
          : stripe // ignore: cast_nullable_to_non_nullable
              as CrosspayProduct,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CrosspayProductsImpl extends _CrosspayProducts {
  _$CrosspayProductsImpl(
      {@JsonKey(name: "playstore") required this.playStore,
      @JsonKey(name: "appstore") required this.appStore,
      required this.stripe})
      : super._();

  factory _$CrosspayProductsImpl.fromJson(Map<String, dynamic> json) =>
      _$$CrosspayProductsImplFromJson(json);

  @override
  @JsonKey(name: "playstore")
  final CrosspayProduct playStore;
  @override
  @JsonKey(name: "appstore")
  final CrosspayProduct appStore;
  @override
  final CrosspayProduct stripe;

  @override
  String toString() {
    return 'CrosspayProducts(playStore: $playStore, appStore: $appStore, stripe: $stripe)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CrosspayProductsImpl &&
            (identical(other.playStore, playStore) ||
                other.playStore == playStore) &&
            (identical(other.appStore, appStore) ||
                other.appStore == appStore) &&
            (identical(other.stripe, stripe) || other.stripe == stripe));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, playStore, appStore, stripe);

  /// Create a copy of CrosspayProducts
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CrosspayProductsImplCopyWith<_$CrosspayProductsImpl> get copyWith =>
      __$$CrosspayProductsImplCopyWithImpl<_$CrosspayProductsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CrosspayProductsImplToJson(
      this,
    );
  }
}

abstract class _CrosspayProducts extends CrosspayProducts {
  factory _CrosspayProducts(
      {@JsonKey(name: "playstore") required final CrosspayProduct playStore,
      @JsonKey(name: "appstore") required final CrosspayProduct appStore,
      required final CrosspayProduct stripe}) = _$CrosspayProductsImpl;
  _CrosspayProducts._() : super._();

  factory _CrosspayProducts.fromJson(Map<String, dynamic> json) =
      _$CrosspayProductsImpl.fromJson;

  @override
  @JsonKey(name: "playstore")
  CrosspayProduct get playStore;
  @override
  @JsonKey(name: "appstore")
  CrosspayProduct get appStore;
  @override
  CrosspayProduct get stripe;

  /// Create a copy of CrosspayProducts
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CrosspayProductsImplCopyWith<_$CrosspayProductsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CrosspayProduct _$CrosspayProductFromJson(Map<String, dynamic> json) {
  return _CrosspayProduct.fromJson(json);
}

/// @nodoc
mixin _$CrosspayProduct {
  String get id => throw _privateConstructorUsedError;
  @JsonKey(name: "product_id")
  String get productId => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  /// Serializes this CrosspayProduct to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CrosspayProduct
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CrosspayProductCopyWith<CrosspayProduct> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CrosspayProductCopyWith<$Res> {
  factory $CrosspayProductCopyWith(
          CrosspayProduct value, $Res Function(CrosspayProduct) then) =
      _$CrosspayProductCopyWithImpl<$Res, CrosspayProduct>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: "product_id") String productId,
      String name,
      String? description,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class _$CrosspayProductCopyWithImpl<$Res, $Val extends CrosspayProduct>
    implements $CrosspayProductCopyWith<$Res> {
  _$CrosspayProductCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CrosspayProduct
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? productId = null,
    Object? name = null,
    Object? description = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      productId: null == productId
          ? _value.productId
          : productId // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CrosspayProductImplCopyWith<$Res>
    implements $CrosspayProductCopyWith<$Res> {
  factory _$$CrosspayProductImplCopyWith(_$CrosspayProductImpl value,
          $Res Function(_$CrosspayProductImpl) then) =
      __$$CrosspayProductImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: "product_id") String productId,
      String name,
      String? description,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$CrosspayProductImplCopyWithImpl<$Res>
    extends _$CrosspayProductCopyWithImpl<$Res, _$CrosspayProductImpl>
    implements _$$CrosspayProductImplCopyWith<$Res> {
  __$$CrosspayProductImplCopyWithImpl(
      _$CrosspayProductImpl _value, $Res Function(_$CrosspayProductImpl) _then)
      : super(_value, _then);

  /// Create a copy of CrosspayProduct
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? productId = null,
    Object? name = null,
    Object? description = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$CrosspayProductImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      productId: null == productId
          ? _value.productId
          : productId // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CrosspayProductImpl implements _CrosspayProduct {
  _$CrosspayProductImpl(
      {required this.id,
      @JsonKey(name: "product_id") required this.productId,
      required this.name,
      this.description,
      final Map<String, dynamic>? metadata})
      : _metadata = metadata;

  factory _$CrosspayProductImpl.fromJson(Map<String, dynamic> json) =>
      _$$CrosspayProductImplFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: "product_id")
  final String productId;
  @override
  final String name;
  @override
  final String? description;
  final Map<String, dynamic>? _metadata;
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'CrosspayProduct(id: $id, productId: $productId, name: $name, description: $description, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CrosspayProductImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.productId, productId) ||
                other.productId == productId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, productId, name, description,
      const DeepCollectionEquality().hash(_metadata));

  /// Create a copy of CrosspayProduct
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CrosspayProductImplCopyWith<_$CrosspayProductImpl> get copyWith =>
      __$$CrosspayProductImplCopyWithImpl<_$CrosspayProductImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CrosspayProductImplToJson(
      this,
    );
  }
}

abstract class _CrosspayProduct implements CrosspayProduct {
  factory _CrosspayProduct(
      {required final String id,
      @JsonKey(name: "product_id") required final String productId,
      required final String name,
      final String? description,
      final Map<String, dynamic>? metadata}) = _$CrosspayProductImpl;

  factory _CrosspayProduct.fromJson(Map<String, dynamic> json) =
      _$CrosspayProductImpl.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: "product_id")
  String get productId;
  @override
  String get name;
  @override
  String? get description;
  @override
  Map<String, dynamic>? get metadata;

  /// Create a copy of CrosspayProduct
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CrosspayProductImplCopyWith<_$CrosspayProductImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

SubscriptionStripeProduct _$SubscriptionStripeProductFromJson(
    Map<String, dynamic> json) {
  return _SubscriptionStripeProduct.fromJson(json);
}

/// @nodoc
mixin _$SubscriptionStripeProduct {
  /// Unique identifier for the object.
  String get id => throw _privateConstructorUsedError;

  /// String representing the object's type. Objects of the same type share the same value.
  @JsonKey(name: 'object')
  String get objectType => throw _privateConstructorUsedError;

  /// Whether the product is currently available for purchase.
  bool get active => throw _privateConstructorUsedError;

  /// Time at which the object was created. Measured in seconds since the Unix epoch.
  int get created => throw _privateConstructorUsedError;

  /// The ID of the Price object that is the default price for this product.
  SubscriptionStripePrice get price => throw _privateConstructorUsedError;

  /// Always true for a deleted object
  bool? get deleted => throw _privateConstructorUsedError;

  /// The product's description, meant to be displayable to the customer.
  String? get description => throw _privateConstructorUsedError;

  /// A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
  List<String> get images => throw _privateConstructorUsedError;

  /// Has the value true if the object exists in live mode or the value false if the object exists in test mode.
  bool get livemode => throw _privateConstructorUsedError;

  /// Set of key-value pairs that you can attach to an object.
  Map<String, dynamic> get metadata => throw _privateConstructorUsedError;

  /// The product's name, meant to be displayable to the customer.
  String get name => throw _privateConstructorUsedError;

  /// Whether this product is shipped (i.e., physical goods).
  bool? get shippable => throw _privateConstructorUsedError;

  /// Extra information about a product which will appear on your customer's credit card statement.
  @JsonKey(name: 'statement_descriptor')
  String? get statementDescriptor => throw _privateConstructorUsedError;

  /// The type of the product. The product is either of type 'good' or 'service'.
  String get type => throw _privateConstructorUsedError;

  /// A label that represents units of this product.
  @JsonKey(name: 'unit_label')
  String? get unitLabel => throw _privateConstructorUsedError;

  /// Time at which the object was last updated. Measured in seconds since the Unix epoch.
  int get updated => throw _privateConstructorUsedError;

  /// A URL of a publicly-accessible webpage for this product.
  String? get url => throw _privateConstructorUsedError;

  /// Serializes this SubscriptionStripeProduct to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SubscriptionStripeProduct
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SubscriptionStripeProductCopyWith<SubscriptionStripeProduct> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionStripeProductCopyWith<$Res> {
  factory $SubscriptionStripeProductCopyWith(SubscriptionStripeProduct value,
          $Res Function(SubscriptionStripeProduct) then) =
      _$SubscriptionStripeProductCopyWithImpl<$Res, SubscriptionStripeProduct>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'object') String objectType,
      bool active,
      int created,
      SubscriptionStripePrice price,
      bool? deleted,
      String? description,
      List<String> images,
      bool livemode,
      Map<String, dynamic> metadata,
      String name,
      bool? shippable,
      @JsonKey(name: 'statement_descriptor') String? statementDescriptor,
      String type,
      @JsonKey(name: 'unit_label') String? unitLabel,
      int updated,
      String? url});

  $SubscriptionStripePriceCopyWith<$Res> get price;
}

/// @nodoc
class _$SubscriptionStripeProductCopyWithImpl<$Res,
        $Val extends SubscriptionStripeProduct>
    implements $SubscriptionStripeProductCopyWith<$Res> {
  _$SubscriptionStripeProductCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubscriptionStripeProduct
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? objectType = null,
    Object? active = null,
    Object? created = null,
    Object? price = null,
    Object? deleted = freezed,
    Object? description = freezed,
    Object? images = null,
    Object? livemode = null,
    Object? metadata = null,
    Object? name = null,
    Object? shippable = freezed,
    Object? statementDescriptor = freezed,
    Object? type = null,
    Object? unitLabel = freezed,
    Object? updated = null,
    Object? url = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      objectType: null == objectType
          ? _value.objectType
          : objectType // ignore: cast_nullable_to_non_nullable
              as String,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as SubscriptionStripePrice,
      deleted: freezed == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      images: null == images
          ? _value.images
          : images // ignore: cast_nullable_to_non_nullable
              as List<String>,
      livemode: null == livemode
          ? _value.livemode
          : livemode // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      shippable: freezed == shippable
          ? _value.shippable
          : shippable // ignore: cast_nullable_to_non_nullable
              as bool?,
      statementDescriptor: freezed == statementDescriptor
          ? _value.statementDescriptor
          : statementDescriptor // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      unitLabel: freezed == unitLabel
          ? _value.unitLabel
          : unitLabel // ignore: cast_nullable_to_non_nullable
              as String?,
      updated: null == updated
          ? _value.updated
          : updated // ignore: cast_nullable_to_non_nullable
              as int,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of SubscriptionStripeProduct
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SubscriptionStripePriceCopyWith<$Res> get price {
    return $SubscriptionStripePriceCopyWith<$Res>(_value.price, (value) {
      return _then(_value.copyWith(price: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$SubscriptionStripeProductImplCopyWith<$Res>
    implements $SubscriptionStripeProductCopyWith<$Res> {
  factory _$$SubscriptionStripeProductImplCopyWith(
          _$SubscriptionStripeProductImpl value,
          $Res Function(_$SubscriptionStripeProductImpl) then) =
      __$$SubscriptionStripeProductImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'object') String objectType,
      bool active,
      int created,
      SubscriptionStripePrice price,
      bool? deleted,
      String? description,
      List<String> images,
      bool livemode,
      Map<String, dynamic> metadata,
      String name,
      bool? shippable,
      @JsonKey(name: 'statement_descriptor') String? statementDescriptor,
      String type,
      @JsonKey(name: 'unit_label') String? unitLabel,
      int updated,
      String? url});

  @override
  $SubscriptionStripePriceCopyWith<$Res> get price;
}

/// @nodoc
class __$$SubscriptionStripeProductImplCopyWithImpl<$Res>
    extends _$SubscriptionStripeProductCopyWithImpl<$Res,
        _$SubscriptionStripeProductImpl>
    implements _$$SubscriptionStripeProductImplCopyWith<$Res> {
  __$$SubscriptionStripeProductImplCopyWithImpl(
      _$SubscriptionStripeProductImpl _value,
      $Res Function(_$SubscriptionStripeProductImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionStripeProduct
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? objectType = null,
    Object? active = null,
    Object? created = null,
    Object? price = null,
    Object? deleted = freezed,
    Object? description = freezed,
    Object? images = null,
    Object? livemode = null,
    Object? metadata = null,
    Object? name = null,
    Object? shippable = freezed,
    Object? statementDescriptor = freezed,
    Object? type = null,
    Object? unitLabel = freezed,
    Object? updated = null,
    Object? url = freezed,
  }) {
    return _then(_$SubscriptionStripeProductImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      objectType: null == objectType
          ? _value.objectType
          : objectType // ignore: cast_nullable_to_non_nullable
              as String,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as SubscriptionStripePrice,
      deleted: freezed == deleted
          ? _value.deleted
          : deleted // ignore: cast_nullable_to_non_nullable
              as bool?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      images: null == images
          ? _value._images
          : images // ignore: cast_nullable_to_non_nullable
              as List<String>,
      livemode: null == livemode
          ? _value.livemode
          : livemode // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      shippable: freezed == shippable
          ? _value.shippable
          : shippable // ignore: cast_nullable_to_non_nullable
              as bool?,
      statementDescriptor: freezed == statementDescriptor
          ? _value.statementDescriptor
          : statementDescriptor // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      unitLabel: freezed == unitLabel
          ? _value.unitLabel
          : unitLabel // ignore: cast_nullable_to_non_nullable
              as String?,
      updated: null == updated
          ? _value.updated
          : updated // ignore: cast_nullable_to_non_nullable
              as int,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SubscriptionStripeProductImpl implements _SubscriptionStripeProduct {
  const _$SubscriptionStripeProductImpl(
      {required this.id,
      @JsonKey(name: 'object') required this.objectType,
      required this.active,
      required this.created,
      required this.price,
      this.deleted,
      this.description,
      required final List<String> images,
      required this.livemode,
      required final Map<String, dynamic> metadata,
      required this.name,
      this.shippable,
      @JsonKey(name: 'statement_descriptor') this.statementDescriptor,
      required this.type,
      @JsonKey(name: 'unit_label') this.unitLabel,
      required this.updated,
      this.url})
      : _images = images,
        _metadata = metadata;

  factory _$SubscriptionStripeProductImpl.fromJson(Map<String, dynamic> json) =>
      _$$SubscriptionStripeProductImplFromJson(json);

  /// Unique identifier for the object.
  @override
  final String id;

  /// String representing the object's type. Objects of the same type share the same value.
  @override
  @JsonKey(name: 'object')
  final String objectType;

  /// Whether the product is currently available for purchase.
  @override
  final bool active;

  /// Time at which the object was created. Measured in seconds since the Unix epoch.
  @override
  final int created;

  /// The ID of the Price object that is the default price for this product.
  @override
  final SubscriptionStripePrice price;

  /// Always true for a deleted object
  @override
  final bool? deleted;

  /// The product's description, meant to be displayable to the customer.
  @override
  final String? description;

  /// A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
  final List<String> _images;

  /// A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
  @override
  List<String> get images {
    if (_images is EqualUnmodifiableListView) return _images;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_images);
  }

  /// Has the value true if the object exists in live mode or the value false if the object exists in test mode.
  @override
  final bool livemode;

  /// Set of key-value pairs that you can attach to an object.
  final Map<String, dynamic> _metadata;

  /// Set of key-value pairs that you can attach to an object.
  @override
  Map<String, dynamic> get metadata {
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metadata);
  }

  /// The product's name, meant to be displayable to the customer.
  @override
  final String name;

  /// Whether this product is shipped (i.e., physical goods).
  @override
  final bool? shippable;

  /// Extra information about a product which will appear on your customer's credit card statement.
  @override
  @JsonKey(name: 'statement_descriptor')
  final String? statementDescriptor;

  /// The type of the product. The product is either of type 'good' or 'service'.
  @override
  final String type;

  /// A label that represents units of this product.
  @override
  @JsonKey(name: 'unit_label')
  final String? unitLabel;

  /// Time at which the object was last updated. Measured in seconds since the Unix epoch.
  @override
  final int updated;

  /// A URL of a publicly-accessible webpage for this product.
  @override
  final String? url;

  @override
  String toString() {
    return 'SubscriptionStripeProduct(id: $id, objectType: $objectType, active: $active, created: $created, price: $price, deleted: $deleted, description: $description, images: $images, livemode: $livemode, metadata: $metadata, name: $name, shippable: $shippable, statementDescriptor: $statementDescriptor, type: $type, unitLabel: $unitLabel, updated: $updated, url: $url)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscriptionStripeProductImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.objectType, objectType) ||
                other.objectType == objectType) &&
            (identical(other.active, active) || other.active == active) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.price, price) || other.price == price) &&
            (identical(other.deleted, deleted) || other.deleted == deleted) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality().equals(other._images, _images) &&
            (identical(other.livemode, livemode) ||
                other.livemode == livemode) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.shippable, shippable) ||
                other.shippable == shippable) &&
            (identical(other.statementDescriptor, statementDescriptor) ||
                other.statementDescriptor == statementDescriptor) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.unitLabel, unitLabel) ||
                other.unitLabel == unitLabel) &&
            (identical(other.updated, updated) || other.updated == updated) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      objectType,
      active,
      created,
      price,
      deleted,
      description,
      const DeepCollectionEquality().hash(_images),
      livemode,
      const DeepCollectionEquality().hash(_metadata),
      name,
      shippable,
      statementDescriptor,
      type,
      unitLabel,
      updated,
      url);

  /// Create a copy of SubscriptionStripeProduct
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubscriptionStripeProductImplCopyWith<_$SubscriptionStripeProductImpl>
      get copyWith => __$$SubscriptionStripeProductImplCopyWithImpl<
          _$SubscriptionStripeProductImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SubscriptionStripeProductImplToJson(
      this,
    );
  }
}

abstract class _SubscriptionStripeProduct implements SubscriptionStripeProduct {
  const factory _SubscriptionStripeProduct(
      {required final String id,
      @JsonKey(name: 'object') required final String objectType,
      required final bool active,
      required final int created,
      required final SubscriptionStripePrice price,
      final bool? deleted,
      final String? description,
      required final List<String> images,
      required final bool livemode,
      required final Map<String, dynamic> metadata,
      required final String name,
      final bool? shippable,
      @JsonKey(name: 'statement_descriptor') final String? statementDescriptor,
      required final String type,
      @JsonKey(name: 'unit_label') final String? unitLabel,
      required final int updated,
      final String? url}) = _$SubscriptionStripeProductImpl;

  factory _SubscriptionStripeProduct.fromJson(Map<String, dynamic> json) =
      _$SubscriptionStripeProductImpl.fromJson;

  /// Unique identifier for the object.
  @override
  String get id;

  /// String representing the object's type. Objects of the same type share the same value.
  @override
  @JsonKey(name: 'object')
  String get objectType;

  /// Whether the product is currently available for purchase.
  @override
  bool get active;

  /// Time at which the object was created. Measured in seconds since the Unix epoch.
  @override
  int get created;

  /// The ID of the Price object that is the default price for this product.
  @override
  SubscriptionStripePrice get price;

  /// Always true for a deleted object
  @override
  bool? get deleted;

  /// The product's description, meant to be displayable to the customer.
  @override
  String? get description;

  /// A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
  @override
  List<String> get images;

  /// Has the value true if the object exists in live mode or the value false if the object exists in test mode.
  @override
  bool get livemode;

  /// Set of key-value pairs that you can attach to an object.
  @override
  Map<String, dynamic> get metadata;

  /// The product's name, meant to be displayable to the customer.
  @override
  String get name;

  /// Whether this product is shipped (i.e., physical goods).
  @override
  bool? get shippable;

  /// Extra information about a product which will appear on your customer's credit card statement.
  @override
  @JsonKey(name: 'statement_descriptor')
  String? get statementDescriptor;

  /// The type of the product. The product is either of type 'good' or 'service'.
  @override
  String get type;

  /// A label that represents units of this product.
  @override
  @JsonKey(name: 'unit_label')
  String? get unitLabel;

  /// Time at which the object was last updated. Measured in seconds since the Unix epoch.
  @override
  int get updated;

  /// A URL of a publicly-accessible webpage for this product.
  @override
  String? get url;

  /// Create a copy of SubscriptionStripeProduct
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubscriptionStripeProductImplCopyWith<_$SubscriptionStripeProductImpl>
      get copyWith => throw _privateConstructorUsedError;
}

SubscriptionStripePrice _$SubscriptionStripePriceFromJson(
    Map<String, dynamic> json) {
  return _SubscriptionStripePrice.fromJson(json);
}

/// @nodoc
mixin _$SubscriptionStripePrice {
  String get id => throw _privateConstructorUsedError;
  int get price => throw _privateConstructorUsedError;
  String get currency => throw _privateConstructorUsedError;
  String get formattedPrice => throw _privateConstructorUsedError;
  String get unitLabel => throw _privateConstructorUsedError;

  /// Serializes this SubscriptionStripePrice to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SubscriptionStripePrice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SubscriptionStripePriceCopyWith<SubscriptionStripePrice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionStripePriceCopyWith<$Res> {
  factory $SubscriptionStripePriceCopyWith(SubscriptionStripePrice value,
          $Res Function(SubscriptionStripePrice) then) =
      _$SubscriptionStripePriceCopyWithImpl<$Res, SubscriptionStripePrice>;
  @useResult
  $Res call(
      {String id,
      int price,
      String currency,
      String formattedPrice,
      String unitLabel});
}

/// @nodoc
class _$SubscriptionStripePriceCopyWithImpl<$Res,
        $Val extends SubscriptionStripePrice>
    implements $SubscriptionStripePriceCopyWith<$Res> {
  _$SubscriptionStripePriceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubscriptionStripePrice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? price = null,
    Object? currency = null,
    Object? formattedPrice = null,
    Object? unitLabel = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as int,
      currency: null == currency
          ? _value.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as String,
      formattedPrice: null == formattedPrice
          ? _value.formattedPrice
          : formattedPrice // ignore: cast_nullable_to_non_nullable
              as String,
      unitLabel: null == unitLabel
          ? _value.unitLabel
          : unitLabel // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SubscriptionStripePriceImplCopyWith<$Res>
    implements $SubscriptionStripePriceCopyWith<$Res> {
  factory _$$SubscriptionStripePriceImplCopyWith(
          _$SubscriptionStripePriceImpl value,
          $Res Function(_$SubscriptionStripePriceImpl) then) =
      __$$SubscriptionStripePriceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      int price,
      String currency,
      String formattedPrice,
      String unitLabel});
}

/// @nodoc
class __$$SubscriptionStripePriceImplCopyWithImpl<$Res>
    extends _$SubscriptionStripePriceCopyWithImpl<$Res,
        _$SubscriptionStripePriceImpl>
    implements _$$SubscriptionStripePriceImplCopyWith<$Res> {
  __$$SubscriptionStripePriceImplCopyWithImpl(
      _$SubscriptionStripePriceImpl _value,
      $Res Function(_$SubscriptionStripePriceImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubscriptionStripePrice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? price = null,
    Object? currency = null,
    Object? formattedPrice = null,
    Object? unitLabel = null,
  }) {
    return _then(_$SubscriptionStripePriceImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      price: null == price
          ? _value.price
          : price // ignore: cast_nullable_to_non_nullable
              as int,
      currency: null == currency
          ? _value.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as String,
      formattedPrice: null == formattedPrice
          ? _value.formattedPrice
          : formattedPrice // ignore: cast_nullable_to_non_nullable
              as String,
      unitLabel: null == unitLabel
          ? _value.unitLabel
          : unitLabel // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SubscriptionStripePriceImpl implements _SubscriptionStripePrice {
  _$SubscriptionStripePriceImpl(
      {required this.id,
      required this.price,
      required this.currency,
      required this.formattedPrice,
      required this.unitLabel});

  factory _$SubscriptionStripePriceImpl.fromJson(Map<String, dynamic> json) =>
      _$$SubscriptionStripePriceImplFromJson(json);

  @override
  final String id;
  @override
  final int price;
  @override
  final String currency;
  @override
  final String formattedPrice;
  @override
  final String unitLabel;

  @override
  String toString() {
    return 'SubscriptionStripePrice(id: $id, price: $price, currency: $currency, formattedPrice: $formattedPrice, unitLabel: $unitLabel)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscriptionStripePriceImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.price, price) || other.price == price) &&
            (identical(other.currency, currency) ||
                other.currency == currency) &&
            (identical(other.formattedPrice, formattedPrice) ||
                other.formattedPrice == formattedPrice) &&
            (identical(other.unitLabel, unitLabel) ||
                other.unitLabel == unitLabel));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, price, currency, formattedPrice, unitLabel);

  /// Create a copy of SubscriptionStripePrice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubscriptionStripePriceImplCopyWith<_$SubscriptionStripePriceImpl>
      get copyWith => __$$SubscriptionStripePriceImplCopyWithImpl<
          _$SubscriptionStripePriceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SubscriptionStripePriceImplToJson(
      this,
    );
  }
}

abstract class _SubscriptionStripePrice implements SubscriptionStripePrice {
  factory _SubscriptionStripePrice(
      {required final String id,
      required final int price,
      required final String currency,
      required final String formattedPrice,
      required final String unitLabel}) = _$SubscriptionStripePriceImpl;

  factory _SubscriptionStripePrice.fromJson(Map<String, dynamic> json) =
      _$SubscriptionStripePriceImpl.fromJson;

  @override
  String get id;
  @override
  int get price;
  @override
  String get currency;
  @override
  String get formattedPrice;
  @override
  String get unitLabel;

  /// Create a copy of SubscriptionStripePrice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubscriptionStripePriceImplCopyWith<_$SubscriptionStripePriceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

StorableSubscription _$StorableSubscriptionFromJson(Map<String, dynamic> json) {
  return _StorableSubscription.fromJson(json);
}

/// @nodoc
mixin _$StorableSubscription {
  /// This is the ID of the subscription. It should generated by your database.
  /// And should be unique (Primary Key).
  String get id => throw _privateConstructorUsedError;

  /// It's the unique transaction id.
  String get transactionId => throw _privateConstructorUsedError;

  /// The product that the user purchased. This is used to grant user access levels.
  String get productId => throw _privateConstructorUsedError;

  /// The store that the user purchased the subscription from.
  SubscriptionStore get source => throw _privateConstructorUsedError;

  /// The unique user id provided in the app to identify the user. This should be
  /// linked to the user table in your database.
  String get appUserId => throw _privateConstructorUsedError;

  /// The time the subscription will expire.
  DateTime get expiresAt => throw _privateConstructorUsedError;

  /// The time the subscription was purchased.
  /// This will get updated when subscription is renewed.
  DateTime get purchaseDate => throw _privateConstructorUsedError;

  /// Subscriptions's renewal status
  SubscriptionRenewalStatus get renewalStatus =>
      throw _privateConstructorUsedError;

  /// The status of the subscription
  SubscriptionStatus get status => throw _privateConstructorUsedError;

  /// Serializes this StorableSubscription to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of StorableSubscription
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StorableSubscriptionCopyWith<StorableSubscription> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StorableSubscriptionCopyWith<$Res> {
  factory $StorableSubscriptionCopyWith(StorableSubscription value,
          $Res Function(StorableSubscription) then) =
      _$StorableSubscriptionCopyWithImpl<$Res, StorableSubscription>;
  @useResult
  $Res call(
      {String id,
      String transactionId,
      String productId,
      SubscriptionStore source,
      String appUserId,
      DateTime expiresAt,
      DateTime purchaseDate,
      SubscriptionRenewalStatus renewalStatus,
      SubscriptionStatus status});
}

/// @nodoc
class _$StorableSubscriptionCopyWithImpl<$Res,
        $Val extends StorableSubscription>
    implements $StorableSubscriptionCopyWith<$Res> {
  _$StorableSubscriptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StorableSubscription
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? transactionId = null,
    Object? productId = null,
    Object? source = null,
    Object? appUserId = null,
    Object? expiresAt = null,
    Object? purchaseDate = null,
    Object? renewalStatus = null,
    Object? status = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      transactionId: null == transactionId
          ? _value.transactionId
          : transactionId // ignore: cast_nullable_to_non_nullable
              as String,
      productId: null == productId
          ? _value.productId
          : productId // ignore: cast_nullable_to_non_nullable
              as String,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as SubscriptionStore,
      appUserId: null == appUserId
          ? _value.appUserId
          : appUserId // ignore: cast_nullable_to_non_nullable
              as String,
      expiresAt: null == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      purchaseDate: null == purchaseDate
          ? _value.purchaseDate
          : purchaseDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      renewalStatus: null == renewalStatus
          ? _value.renewalStatus
          : renewalStatus // ignore: cast_nullable_to_non_nullable
              as SubscriptionRenewalStatus,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as SubscriptionStatus,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StorableSubscriptionImplCopyWith<$Res>
    implements $StorableSubscriptionCopyWith<$Res> {
  factory _$$StorableSubscriptionImplCopyWith(_$StorableSubscriptionImpl value,
          $Res Function(_$StorableSubscriptionImpl) then) =
      __$$StorableSubscriptionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String transactionId,
      String productId,
      SubscriptionStore source,
      String appUserId,
      DateTime expiresAt,
      DateTime purchaseDate,
      SubscriptionRenewalStatus renewalStatus,
      SubscriptionStatus status});
}

/// @nodoc
class __$$StorableSubscriptionImplCopyWithImpl<$Res>
    extends _$StorableSubscriptionCopyWithImpl<$Res, _$StorableSubscriptionImpl>
    implements _$$StorableSubscriptionImplCopyWith<$Res> {
  __$$StorableSubscriptionImplCopyWithImpl(_$StorableSubscriptionImpl _value,
      $Res Function(_$StorableSubscriptionImpl) _then)
      : super(_value, _then);

  /// Create a copy of StorableSubscription
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? transactionId = null,
    Object? productId = null,
    Object? source = null,
    Object? appUserId = null,
    Object? expiresAt = null,
    Object? purchaseDate = null,
    Object? renewalStatus = null,
    Object? status = null,
  }) {
    return _then(_$StorableSubscriptionImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      transactionId: null == transactionId
          ? _value.transactionId
          : transactionId // ignore: cast_nullable_to_non_nullable
              as String,
      productId: null == productId
          ? _value.productId
          : productId // ignore: cast_nullable_to_non_nullable
              as String,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as SubscriptionStore,
      appUserId: null == appUserId
          ? _value.appUserId
          : appUserId // ignore: cast_nullable_to_non_nullable
              as String,
      expiresAt: null == expiresAt
          ? _value.expiresAt
          : expiresAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      purchaseDate: null == purchaseDate
          ? _value.purchaseDate
          : purchaseDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      renewalStatus: null == renewalStatus
          ? _value.renewalStatus
          : renewalStatus // ignore: cast_nullable_to_non_nullable
              as SubscriptionRenewalStatus,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as SubscriptionStatus,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StorableSubscriptionImpl implements _StorableSubscription {
  _$StorableSubscriptionImpl(
      {required this.id,
      required this.transactionId,
      required this.productId,
      required this.source,
      required this.appUserId,
      required this.expiresAt,
      required this.purchaseDate,
      required this.renewalStatus,
      required this.status});

  factory _$StorableSubscriptionImpl.fromJson(Map<String, dynamic> json) =>
      _$$StorableSubscriptionImplFromJson(json);

  /// This is the ID of the subscription. It should generated by your database.
  /// And should be unique (Primary Key).
  @override
  final String id;

  /// It's the unique transaction id.
  @override
  final String transactionId;

  /// The product that the user purchased. This is used to grant user access levels.
  @override
  final String productId;

  /// The store that the user purchased the subscription from.
  @override
  final SubscriptionStore source;

  /// The unique user id provided in the app to identify the user. This should be
  /// linked to the user table in your database.
  @override
  final String appUserId;

  /// The time the subscription will expire.
  @override
  final DateTime expiresAt;

  /// The time the subscription was purchased.
  /// This will get updated when subscription is renewed.
  @override
  final DateTime purchaseDate;

  /// Subscriptions's renewal status
  @override
  final SubscriptionRenewalStatus renewalStatus;

  /// The status of the subscription
  @override
  final SubscriptionStatus status;

  @override
  String toString() {
    return 'StorableSubscription(id: $id, transactionId: $transactionId, productId: $productId, source: $source, appUserId: $appUserId, expiresAt: $expiresAt, purchaseDate: $purchaseDate, renewalStatus: $renewalStatus, status: $status)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StorableSubscriptionImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.transactionId, transactionId) ||
                other.transactionId == transactionId) &&
            (identical(other.productId, productId) ||
                other.productId == productId) &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.appUserId, appUserId) ||
                other.appUserId == appUserId) &&
            (identical(other.expiresAt, expiresAt) ||
                other.expiresAt == expiresAt) &&
            (identical(other.purchaseDate, purchaseDate) ||
                other.purchaseDate == purchaseDate) &&
            (identical(other.renewalStatus, renewalStatus) ||
                other.renewalStatus == renewalStatus) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, transactionId, productId,
      source, appUserId, expiresAt, purchaseDate, renewalStatus, status);

  /// Create a copy of StorableSubscription
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StorableSubscriptionImplCopyWith<_$StorableSubscriptionImpl>
      get copyWith =>
          __$$StorableSubscriptionImplCopyWithImpl<_$StorableSubscriptionImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StorableSubscriptionImplToJson(
      this,
    );
  }
}

abstract class _StorableSubscription implements StorableSubscription {
  factory _StorableSubscription(
      {required final String id,
      required final String transactionId,
      required final String productId,
      required final SubscriptionStore source,
      required final String appUserId,
      required final DateTime expiresAt,
      required final DateTime purchaseDate,
      required final SubscriptionRenewalStatus renewalStatus,
      required final SubscriptionStatus status}) = _$StorableSubscriptionImpl;

  factory _StorableSubscription.fromJson(Map<String, dynamic> json) =
      _$StorableSubscriptionImpl.fromJson;

  /// This is the ID of the subscription. It should generated by your database.
  /// And should be unique (Primary Key).
  @override
  String get id;

  /// It's the unique transaction id.
  @override
  String get transactionId;

  /// The product that the user purchased. This is used to grant user access levels.
  @override
  String get productId;

  /// The store that the user purchased the subscription from.
  @override
  SubscriptionStore get source;

  /// The unique user id provided in the app to identify the user. This should be
  /// linked to the user table in your database.
  @override
  String get appUserId;

  /// The time the subscription will expire.
  @override
  DateTime get expiresAt;

  /// The time the subscription was purchased.
  /// This will get updated when subscription is renewed.
  @override
  DateTime get purchaseDate;

  /// Subscriptions's renewal status
  @override
  SubscriptionRenewalStatus get renewalStatus;

  /// The status of the subscription
  @override
  SubscriptionStatus get status;

  /// Create a copy of StorableSubscription
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StorableSubscriptionImplCopyWith<_$StorableSubscriptionImpl>
      get copyWith => throw _privateConstructorUsedError;
}
